
Database Design & Usage Guide for Spring Boot Microservices
===========================================================

Goal
----
This file is your reusable template & checklist for designing and using the
**database layer** in Spring Boot microservices (with JPA/Hibernate, MySQL/Postgres, etc.).

Think of it as the glue between:
- Your **Entity** model (Java classes)
- Your **actual database schema** (tables, columns, indexes)
- Your **environment setup** (dev/test/prod DBs & configs)


Big Picture
-----------
Request → Controller → Service → Repository → Entity → **Database**

The database layer answers:
- How is data physically stored?
- How do tables relate to each other?
- How do we handle migrations & schema evolution?
- How do we configure DB per environment?


Golden Rules / Rules of Thumb
-----------------------------
1. Model what you **actually need** now, but keep future growth in mind.
2. Prefer **normalized** schemas first (3NF), then denormalize *only* for performance.
3. Use proper data types: no `VARCHAR(255)` for everything, no `DOUBLE` for money.
4. Always design with **indexes** in mind (PKs, unique, foreign-key, search columns).
5. Use DB constraints (NOT NULL, UNIQUE, FK) to protect data consistency.
6. For schema changes, use **migrations** (Flyway/Liquibase), not manual SQL in prod.
7. Separate DBs per environment (local, dev, stage, prod) and use separate credentials.


1. Choosing a Relational DB
---------------------------
Common choices:
- MySQL / MariaDB
- PostgreSQL

For learning & most microservices:
- MySQL or PostgreSQL are perfect choices.

Rule of thumb:
- Pick one (e.g., MySQL) and stick to it for your learning path.
- For advanced or enterprise, Postgres often has richer features.


2. Database Setup (Local)
-------------------------
Example: Local MySQL

1. Install MySQL locally (or use Docker).
2. Create a database for your microservice:

```sql
CREATE DATABASE nyx_products
  CHARACTER SET utf8mb4
  COLLATE utf8mb4_unicode_ci;

SHOW DATABASES;
```

Why `utf8mb4`?
- Supports full Unicode, including emojis and international characters.
- `utf8mb4_unicode_ci` is a good default collation for case-insensitive search.

Rule of thumb:
- Always set explicit charset/collation; don’t trust defaults.


3. Connecting Spring Boot to the DB
-----------------------------------
Typical `application.yml` for MySQL:

```yaml
spring:
  datasource:
    url: jdbc:mysql://${DB_HOST:localhost}:${DB_PORT:3306}/${DB_NAME:nyx_products}
    username: ${DB_USER:root}
    password: ${DB_PASSWORD:password}
    driver-class-name: com.mysql.cj.jdbc.Driver

  jpa:
    hibernate:
      ddl-auto: update   # for local dev only (see below)
    show-sql: true
    properties:
      hibernate.format_sql: true
```

`ddl-auto` options (Hibernate):
- `create`          – drop and create schema on startup (dangerous in prod).
- `create-drop`     – create at startup, drop on shutdown.
- `update`          – update schema to match entities (ok-ish for dev, not prod).
- `validate`        – validate schema; fail if mismatch.
- `none`            – don’t touch schema.

Rule of thumb:
- For **local dev**: `update` or `create` / `create-drop` is fine to move fast.
- For **prod**: use `validate` or `none` and rely on migrations, NOT auto-ddl.


4. Mapping Entities → Tables
----------------------------
Every `@Entity` maps to a DB table.

Basic mapping example:

```java
@Entity
@Table(name = "x")
public class XEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 100)
    private String name;

    @Column(length = 255)
    private String description;
}
```

Would generate (conceptually) something like:

```sql
CREATE TABLE x (
  id BIGINT NOT NULL AUTO_INCREMENT,
  name VARCHAR(100) NOT NULL,
  description VARCHAR(255),
  PRIMARY KEY (id)
);
```

Rule of thumb:
- Be explicit in `@Column` about `nullable`, `length`, precision/scale for numbers.


5. Data Types – Good Defaults
-----------------------------
Use types that match semantics, not just "what works".

Common patterns:

- IDs:
  - Java: `Long`
  - DB: `BIGINT` (MySQL/Postgres)

- Text:
  - Short fixed-size fields: `VARCHAR(100)` / `VARCHAR(255)`.
  - Long text: `TEXT` (MySQL) / `text` (Postgres).

- Money:
  - Java: `BigDecimal`
  - DB: `DECIMAL(15,2)` or `NUMERIC(15,2)`

- Booleans:
  - Java: `boolean` or `Boolean`
  - DB: `TINYINT(1)` (MySQL), `boolean` (Postgres)

- Timestamps:
  - Java: `Instant` / `OffsetDateTime`
  - DB: `TIMESTAMP` with timezone support if possible.

Rule of thumb:
- Never use `double`/`float` for money.
- Use appropriate `precision` + `scale` for decimals.


6. Relationships & Foreign Keys
-------------------------------
Relationships in ORM map to foreign keys in DB.

Example: Many X to One Y (ManyToOne).

Entity:

```java
@ManyToOne(fetch = FetchType.LAZY, optional = false)
@JoinColumn(name = "y_id")
private YEntity y;
```

DB:

```sql
ALTER TABLE x
  ADD COLUMN y_id BIGINT NOT NULL,
  ADD CONSTRAINT fk_x_y FOREIGN KEY (y_id) REFERENCES y(id);
```

Rule of thumb:
- Always define foreign keys at DB level – this protects referential integrity.
- Default to `LAZY` loading for associations.


7. Indexes
----------
Indexes speed up reads but cost space and write performance.

Common indexes:

- Primary key: automatically indexed.
- Unique business keys: `UNIQUE` index.
- Search fields: `INDEX` on columns frequently used in `WHERE` clauses.

Example:

```sql
CREATE UNIQUE INDEX ux_x_business_key ON x (business_key);
CREATE INDEX ix_x_status_created_at ON x (status, created_at);
```

Rule of thumb:
- Add indexes only when needed (on columns frequently used for filtering/joining).
- Monitor queries (explain plan) in real projects.


8. Migrations (Flyway / Liquibase)
----------------------------------
For **real** microservices, schema changes must be tracked and repeatable.

Flyway example:

Directory structure:
- `src/main/resources/db/migration`
  - `V1__init_schema.sql`
  - `V2__add_status_to_x.sql`
  - `V3__create_y_table.sql`

`application.yml`:

```yaml
spring:
  flyway:
    enabled: true
    locations: classpath:db/migration
```

Migration file example (`V1__init_schema.sql`):

```sql
CREATE TABLE x (
  id BIGINT NOT NULL AUTO_INCREMENT,
  name VARCHAR(100) NOT NULL,
  description VARCHAR(255),
  created_at TIMESTAMP NOT NULL,
  updated_at TIMESTAMP NOT NULL,
  PRIMARY KEY (id)
);
```

Rule of thumb:
- Each DB change = new migration file.
- Never manually edit old migration files once applied to shared envs.


9. Environments: Dev / Test / Stage / Prod
------------------------------------------
You will have multiple databases:

- Local dev DB (run on your laptop / Docker).
- CI/test DB (used in tests).
- Stage/QA DB (shared non-prod).
- Prod DB (live data).

Use Spring profiles + environment variables.

Example:

`application.yml` (base):

```yaml
spring:
  datasource:
    url: jdbc:mysql://${DB_HOST:localhost}:${DB_PORT:3306}/${DB_NAME:nyx_products}
    username: ${DB_USER:root}
    password: ${DB_PASSWORD:password}
```

`application-prod.yml`:

```yaml
spring:
  datasource:
    url: jdbc:mysql://${DB_HOST}:${DB_PORT:3306}/${DB_NAME}
    username: ${DB_USER}
    password: ${DB_PASSWORD}
  jpa:
    hibernate:
      ddl-auto: validate
```

Rule of thumb:
- **Never** use the same DB for dev and prod.
- **Never** use `ddl-auto=update/create` in prod.


10. Initial Data / Seed Data
----------------------------
Sometimes you want initial data (reference data, test data).

Options:
- Flyway `V*_*.sql` that insert rows.
- Application `CommandLineRunner` for dev-only seeding.
- Separate “data” migrations (e.g., `R1__seed_reference_data.sql`).

Rule of thumb:
- For reference/lookup data, prefer migrations so it’s tracked with schema.
- For dummy local-only data, `CommandLineRunner` is fine.


11. Performance Considerations
------------------------------

- Avoid fetching huge result sets without pagination.
- Be careful with large `@OneToMany` collections; they can explode into many rows.
- Consider read-only views / materialized views for heavy reporting use cases.
- Use projections and pagination in repositories to limit data transfer.

Rule of thumb:
- Default to **paginated** endpoints for lists in microservices.
- Use logs + DB query analysis in real projects to spot slow queries.


12. Deletion Strategies
-----------------------

Hard delete:
- Rows removed from table with `DELETE`.

Soft delete:
- Mark row as deleted with flag:

```sql
ALTER TABLE x ADD COLUMN deleted BOOLEAN NOT NULL DEFAULT FALSE;
```

Entity:

```java
@Column(nullable = false)
private boolean deleted = false;
```

Queries then filter on `deleted = false`.

Rule of thumb:
- Soft delete if you need audit/trail or legal retention.
- Hard delete if data truly can vanish without impact.


13. Multi-Tenancy (Advanced)
----------------------------
For multi-tenant systems, typical strategies:

- Separate DB per tenant.
- Separate schema per tenant.
- Shared table with tenant_id column.

This is advanced; for now just remember that DB design must consider tenancy
if needed.


Step-by-Step Checklist When Designing DB for a New Microservice
----------------------------------------------------------------

1. **Define the core entities in words.**
   - “We have User, Order, Payment, Product, etc.”

2. **For each entity, define fields & relationships.**
   - Required vs optional.
   - One-to-many / many-to-one / many-to-many.

3. **Choose data types for each field.**
   - IDs, text, money, timestamps, booleans, enums.

4. **Decide table names & naming conventions.**
   - `users`, `orders`, `order_items`, `payments`, etc.

5. **Plan primary keys & unique constraints.**
   - PK = `id` (BIGINT) for most tables.
   - Business keys (e.g., `order_number`) as unique where needed.

6. **Plan foreign keys.**
   - Enforce relationships at DB level with `FOREIGN KEY` constraints.

7. **Plan indexes.**
   - For frequent search/filter columns.

8. **Create initial migration (V1__init_schema.sql).**
   - Tables + constraints + indexes.

9. **Configure Spring Boot to connect to local DB.**
   - `spring.datasource.*` and JPA properties.

10. **Align entities with schema.**
    - Ensure `@Entity` and `@Column` match actual SQL definitions.

11. **Test basic CRUD flows.**
    - Start the app, run sample requests, verify DB rows.

12. **Plan further migrations.**
    - Each new feature that needs schema changes = new migration file.


Example: Simple Order Microservice Schema (High-Level)
------------------------------------------------------

Tables:
- `customers`
- `orders`
- `order_items`

Relationships:
- One customer has many orders.
- One order has many order_items.
- One order_item references a product by product_id (could be external).

Example DDL (simplified):

```sql
CREATE TABLE customers (
  id BIGINT NOT NULL AUTO_INCREMENT,
  name VARCHAR(100) NOT NULL,
  email VARCHAR(255) NOT NULL,
  created_at TIMESTAMP NOT NULL,
  PRIMARY KEY (id),
  UNIQUE KEY ux_customers_email (email)
);

CREATE TABLE orders (
  id BIGINT NOT NULL AUTO_INCREMENT,
  customer_id BIGINT NOT NULL,
  status VARCHAR(20) NOT NULL,
  total_amount DECIMAL(15,2) NOT NULL,
  currency VARCHAR(3) NOT NULL,
  created_at TIMESTAMP NOT NULL,
  PRIMARY KEY (id),
  CONSTRAINT fk_orders_customer FOREIGN KEY (customer_id) REFERENCES customers(id)
);

CREATE TABLE order_items (
  id BIGINT NOT NULL AUTO_INCREMENT,
  order_id BIGINT NOT NULL,
  product_id BIGINT NOT NULL,
  quantity INT NOT NULL,
  unit_price DECIMAL(15,2) NOT NULL,
  PRIMARY KEY (id),
  CONSTRAINT fk_items_order FOREIGN KEY (order_id) REFERENCES orders(id)
);
```

Final Thoughts
--------------
- The DB is the **source of truth** for your microservice's state.
- Good database design makes your entities, repositories, and services
  simpler and more robust.
- Reuse this file whenever you start a new microservice: think in terms of
  **entities → tables → relationships → migrations → env configs**.
